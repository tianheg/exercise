<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>圆锥文字</title>
    <style>
      canvas {
        width: 100%;
        height: 100vh;
        display: block;
        cursor: grab;
      }

      canvas#map {
        width: 25vmin;
        height: 25vmin;
        position: fixed;
        top: 0;
        left: 0;
        display: block;
        z-index: 1;
        cursor: unset;
      }
    </style>
  </head>

  <body>
    <canvas id="map"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/three@0.99.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.99.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.5.0/gsap.min.js"></script>

    <script type="text/javascript">
      // 作者：https://twitter.com/ycwhk
      // ----
      // Boot
      // ----

      const $ = THREE
      const OrbitControls = $.OrbitControls

      const renderer = new $.WebGLRenderer({ antialias: true })
      const scene = new $.Scene()
      const camera = new $.PerspectiveCamera(75, 2, 0.01, 100)
      const controls = new OrbitControls(camera, renderer.domElement)
      window.addEventListener('resize', () => {
        const { clientWidth, clientHeight } = renderer.domElement
        renderer.setPixelRatio(window.devicePixelRatio)
        renderer.setSize(clientWidth, clientHeight, false)
        camera.aspect = clientWidth / clientHeight
        camera.updateProjectionMatrix()
      })
      document.body.prepend(renderer.domElement)
      window.dispatchEvent(new Event('resize'))
      renderer.setAnimationLoop((t) => {
        renderer.render(scene, camera)
        controls.update()
      })

      // +-----
      // Canvas
      // -----+

      const canvas = document.querySelector('canvas#map')
      canvas.width = 512
      canvas.height = 512
      const ctx = canvas.getContext('2d')

      ctx.beginPath()
      ctx.moveTo(canvas.width, canvas.height / 2)
      ctx.lineTo(0, canvas.height / 2)
      ctx.strokeStyle = 'black'
      ctx.lineWidth = 10
      ctx.stroke()

      const sz = 48
      ctx.font = `bold ${sz}px monospace`
      ctx.textBaseline = 'top'
      const text0 = 'World'
      for (
        let i = canvas.height / 2, I = canvas.height;
        i < I;
        i += sz * 1.33
      ) {
        ctx.fillText(text0, (i / I) * sz * 5, i)
      }

      ctx.font = '256px serif'
      ctx.textBaseline = 'middle'
      const text1 = 'Hello'
      ctx.translate(canvas.width / 2, canvas.height / 2)
      ctx.rotate(-Math.PI / 4)
      ctx.fillText(text1, ctx.measureText(text1).width / -2, 0)

      // ----
      // Main
      // ----

      camera.position.set(2, 2, 1)
      scene.background = new $.Color('white')
      scene.fog = new $.Fog(scene.background, 0, 8)
      renderer.shadowMap.enabled = true

      const light = new $.DirectionalLight()
      light.position.set(0, 8, 0)
      light.castShadow = true
      scene.add(light)

      const r = 2
      const h = 3
      const geom = new $.ConeBufferGeometry(r, h, 128, 128, true)
      geom.translate(0, -h / 2 - 0.01, 0)
      const map = new $.CanvasTexture(canvas)
      map.repeat.set(-2, 2) // flip x
      map.wrapS = $.RepeatWrapping
      map.wrapT = $.RepeatWrapping
      map.needsUpdate = true
      const mat = new $.MeshLambertMaterial({
        map,
        alphaTest: 0.5,
        transparent: true,
        side: $.DoubleSide,
      })
      const mesh = new $.Mesh(geom, mat)
      mesh.customDepthMaterial = new $.MeshDepthMaterial({
        depthPacking: $.RGBADepthPacking,
        alphaTest: mat.alphaTest,
        map: mat.map,
      })
      mesh.castShadow = true

      const t0 = new $.Group()
      t0.add(mesh)
      t0.rotation.z = Math.PI / 2 + Math.atan2(r, h)
      const t1 = new $.Group()
      t1.add(t0)
      scene.add(t1)

      //// Ground

      {
        const geom = new $.PlaneBufferGeometry(16, 16)
        geom.rotateX(-Math.PI / 2)
        const mat = new $.ShadowMaterial({ transparent: true, opacity: 0.2 })
        const mesh = new $.Mesh(geom, mat)
        mesh.receiveShadow = true
        scene.add(mesh)
      }

      //// Animate

      gsap
        .timeline()
        .to(mesh.rotation, {
          y: Math.PI * 2,
          duration: 4,
          repeat: -1,
          ease: 'none',
        })
        .to(
          t1.rotation,
          { y: Math.PI * 2, duration: 5, repeat: -1, ease: 'none' },
          '<',
        )
    </script>
  </body>
</html>
