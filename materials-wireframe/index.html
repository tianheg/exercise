<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>个人形象</title>
    <style>
      html,
      body {
        padding: 0;
        margin: 0;
      }
    </style>
  </head>

  <body>
    <script type="x-shader/x-vertex" id="vertexShader">

      attribute vec3 center;
      varying vec3 vCenter;

      void main() {

        vCenter = center;

        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }
    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">

      uniform float widthFactor;

      varying vec3 vCenter;

      float edgeFactorTri() {

        vec3 d = fwidth( vCenter.xyz );

        vec3 a3 = smoothstep( vec3( 0.0 ), d * widthFactor, vCenter.xyz );

        return min( min( a3.x, a3.y ), a3.z );

      }

      void main() {

        if ( edgeFactorTri() > 0.99 ) discard;

        gl_FragColor = gl_FrontFacing ? vec4( 0.9, 0.9, 1.0, 1.0 ) : vec4( 0.4, 0.4, 0.5, 1.0 );

      }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/three@0.120/build/three.min.js"></script>
    <script
      tyep="text/javascript"
      src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"
    ></script>
    <script
      tyep="text/javascript"
      src="https://cdn.jsdelivr.net/npm/three@0.120/examples/js/loaders/STLLoader.js"
    ></script>
    <script
      tyep="text/javascript"
      src="https://cdn.jsdelivr.net/npm/three@0.120/examples/js/controls/OrbitControls.js"
    ></script>

    <script type="text/javascript">
      let GUI = dat.GUI

      const API = {
        widthFactor: 0.5,
      }

      let renderer, scene, camera, mesh

      init()

      function init() {
        renderer = new THREE.WebGLRenderer({ antialias: true })
        renderer.setPixelRatio(window.devicePixelRatio)
        renderer.setSize(window.innerWidth, window.innerHeight)
        document.body.appendChild(renderer.domElement)

        scene = new THREE.Scene()

        camera = new THREE.PerspectiveCamera(
          40,
          window.innerWidth / window.innerHeight,
          1,
          500,
        )
        camera.position.z = 150

        const loader = new THREE.STLLoader()
        loader.load('./my1.stl', function (geometry) {
          const uniforms = { widthFactor: { value: API.widthFactor } }

          const material2 = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader:
              document.getElementById('fragmentShader').textContent,
            side: THREE.DoubleSide,
          })

          material2.extensions.derivatives = true

          geometry.deleteAttribute('normal')
          geometry.deleteAttribute('uv')

          setupAttributes(geometry)

          mesh = new THREE.Mesh(geometry, material2)
          mesh.position.set(0, 0, 0)

          mesh.scale.set(2, 2, 2)

          scene.add(mesh)

          const controls = new THREE.OrbitControls(camera, renderer.domElement)
          controls.target.set(0, -15, -80)
          controls.update()

          animate()
        })

        const gui = new GUI()

        gui.add(API, 'widthFactor', 0.1, 2).onChange(function () {
          mesh.material.uniforms.widthFactor.value = API.widthFactor
        })

        gui.open()

        //

        window.addEventListener('resize', onWindowResize, false)
      }

      function setupAttributes(geometry) {
        const vectors = [
          new THREE.Vector3(1, 0, 0),
          new THREE.Vector3(0, 1, 0),
          new THREE.Vector3(0, 0, 1),
        ]

        const position = geometry.attributes.position
        const centers = new Float32Array(position.count * 3)

        for (let i = 0, l = position.count; i < l; i++) {
          vectors[i % 3].toArray(centers, i * 3)
        }

        geometry.setAttribute('center', new THREE.BufferAttribute(centers, 3))
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight
        camera.updateProjectionMatrix()

        renderer.setSize(window.innerWidth, window.innerHeight)
      }

      function animate() {
        requestAnimationFrame(animate)

        renderer.render(scene, camera)
      }
    </script>
  </body>
</html>
